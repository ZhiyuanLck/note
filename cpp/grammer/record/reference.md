# 引用

- 引用必须初始化
- 引用类型无法在顶层被cv限定
- 引用**不是对象**，不必占用存储，但是编译器会在必要的时候分配空间来实现语义（比如引用类型的非静态数据成员会增加类的大小，即对应的内存地址的大小）
- 不存在`void`的引用，也不存在引用的引用、引用的数组、指向引用的指针

## 引用坍塌(reference collapsing)

通过模板或`typedef`中的类型操作构成的引用的引用会触发引用坍塌规则

- 右值引用的右值引用坍塌成右值引用
- 其他组合坍塌成左值引用

## 左值引用

- 建立既存对象的别名，且可以拥有不同的cv限定
- 在函数调用中实现按引用传递语义
- 当函数的返回值是左值引用时，函数调用表达式成为左值表达式

## 右值引用

右值引用可用来延长临时对象的声明周期（`const`限定的左值引用也可以）

```cpp
  const int &r1 = 1; // 到 const 的左值引用延长生命周期
  // r1 += 2;        // 错误，不能修改
  int &&r2 = 1;      // 右值引用延长声明周期
  r2 += 2;           // 正确
  std::cout << r2 << '\n';
```

更重要的是，当函数同时具有右值引用和左值引用的重载时，**右值引用重载绑定到右值，左值引用重载绑定到左值**。这允许在适当时机自动选择移动构造函数、移动赋值运算符和其他具移动能力的函数。

右值引用也可以绑定到亡值。（待补充）

## 转发引用（待补充）
